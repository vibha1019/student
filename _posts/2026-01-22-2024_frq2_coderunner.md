---
layout: post
title: AP CSA 2024 FRQ 2 - Scoreboard Class
permalink: /apcsa/frq/2024/2
comments: True
---

## Overview

This FRQ required implementing a `Scoreboard` class to track scores in a turn-based game between two teams. The class needed to handle team switching, score tracking, and state management.

## Proof

### Code Implementation
![Code Proof]({{ site.baseurl }}/images/frq_2024.png)

### Program Output
![Output]({{ site.baseurl }}/images/frq_output.png)

## Code Solution
```java
class Scoreboard {
    // Define your properties HERE
    private String team1Name;
    private String team2Name;
    private int team1Score;
    private int team2Score;
    private boolean isTeam1Active;

    public Scoreboard(String team1Name, String team2Name) {
        this.team1Name = team1Name;
        this.team2Name = team2Name;
        this.team1Score = 0;
        this.team2Score = 0;
        this.isTeam1Active = true;  
    }

    public void recordPlay(int points) {
        if (points > 0) {
            // Add points to the active team's score
            if (isTeam1Active) {
                team1Score += points;
            } else {
                team2Score += points;
            }
        } else {
            isTeam1Active = !isTeam1Active;
        }
    }

    public String getScore() {
        String activeTeamName;
        if (isTeam1Active) {
            activeTeamName = team1Name;
        } else {
            activeTeamName = team2Name;
        }
        
        return team1Score + "-" + team2Score + "-" + activeTeamName;
    }
}
``` 

## Key Concepts Demonstrated

- **Object-Oriented Design**: Modeling a real-world system with a class
- **State Management**: Tracking multiple changing data points across method calls
- **Toggle Pattern**: Clean team-switching with boolean negation
- **Data Integrity**: Private variables protecting internal state

## Reflection

### What Made This Challenging

Managing **mutable state** across multiple method calls was the core challenge. The Scoreboard had to "remember" everything between calls. The trickiest part was realizing `recordPlay(0)` actively switches teams rather than doing nothing.

### My Approach

I identified what to track: two team names (constant), two scores (changing), and active status (toggling). I used a boolean for the active team since `if (isTeam1Active)` reads better than `if (activeTeam == 1)`.

The `recordPlay` logic simplified to:
- Non-zero → update score, keep turn
- Zero → switch turn, no score change

### Pitfalls I Avoided

1. **Overcomplicating team tracking**: Almost used a String variable instead of the cleaner boolean approach
2. **Score update confusion**: Carefully traced which team's score to update based on `isTeam1Active`
3. **Unnecessary complexity**: Team names never change, so no setters needed

### Quick Wins

- Used descriptive variable names (`isTeam1Active` vs `active`)
- Tested the constructor + `getScore()` before moving to `recordPlay()`
- Double-checked the exact string format required

### Real-World Connections

Similar patterns appear in:
- Turn-based game apps
- Workflow systems (document routing)
- Collaborative tool access control

### Key Takeaway

FRQ success isn't just the right answer—it's showing you understand **why** each piece of code exists and how it fits the overall solution.