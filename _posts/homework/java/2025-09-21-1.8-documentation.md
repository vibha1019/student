---
title: Documentation with Comments
comments: true
layout: post
permalink: /csa/unit_01/1_8/homework/
description: Variables and Data Types
author: Eshika Pallapotu, Nithika Vivek, Saanvi Dogra
---
# CSA Unit 1.8: Documentation with Comments\n",

## Lesson Plan

**Learning Objectives:**
- Understand the purpose and importance of code documentation
- Master Javadoc comment syntax and structure
- Learn to write effective preconditions and postconditions
- Apply documentation best practices to classes and methods


**AP Exam Focus:** Required for FRQ responses, demonstrates professional programming practices



We need 2 volunteers to come up to play a game!

## Part 1: Why Documentation Matters

Documentation serves multiple audiences:
- **Other developers:** How do I use this method? What parameters does it expect?
- **Maintainers:** Why was this implemented this way? What are the edge cases?
- **Testers:** What should this method do in different scenarios?
- **Your future self:** Will you remember your logic in 3 months?

**Think of documentation as the user manual for your code.**

### Types of Java Comments:
1. **Single-line comments:** `//` - Quick notes and explanations
2. **Multi-line comments:** `/* */` - Longer explanations
3. **Javadoc comments:** `/** */` - API documentation (our focus today!)

---

##  Part 2: Javadoc Comment Structure

Javadoc uses special tags to create comprehensive documentation:
- `@param` - Describes a parameter
- `@return` - Describes the return value
- `@throws` - Describes exceptions that might be thrown

**Basic Template:**
```java
/**
 * Brief description of what the method does.
 * 
 * More detailed explanation if needed, including algorithm
 * information, usage notes, or important behaviors.
 *
 * @param paramName description of the parameter
 * @return description of what is returned
 */
```

---


```Java
/**
 * Calculates the final grade for a student based on weighted categories.
 * The grade is computed using the formula: 
 * (homework * 0.3) + (tests * 0.5) + (participation * 0.2)
 *
 * @param homework the average homework score (0.0 to 100.0)
 * @param tests the average test score (0.0 to 100.0)  
 * @param participation the participation score (0.0 to 100.0)
 * @return the weighted final grade as a percentage (0.0 to 100.0)
 */
public double calculateFinalGrade(double homework, double tests, double participation) {
    return homework * 0.3 + tests * 0.5 + participation * 0.2;
}

// Test the method
System.out.println("Final Grade: " + calculateFinalGrade(85.0, 92.0, 88.0));
```

    Final Grade: 89.1


## Part 3: Preconditions and Postconditions

**Preconditions:** What must be true BEFORE the method is called
**Postconditions:** What will be true AFTER the method completes successfully

These create a **contract** between the method and its callers.

### Why They Matter:
- Clarify responsibilities
- Define expected behavior
- Help identify bugs
- Essential for AP FRQs!

---


```Java
/**
 * Withdraws money from the bank account.
 * 
 * Preconditions: 
 * - amount must be positive
 * - amount must not exceed current balance
 * - account must not be frozen
 * 
 * Postconditions:
 * - balance is reduced by the withdrawal amount
 * - transaction is recorded in account history
 * - returns true if withdrawal successful
 *
 * @param amount the amount to withdraw (must be positive)
 * @return true if withdrawal successful, false otherwise
 */

public boolean withdraw(double amount) {
    // Local variable definitions
    double balance = 500.0;      // example current balance
    boolean isFrozen = false;    // example account state

    // Preconditions: amount must be positive, not exceed balance, and account not frozen
    if (amount <= 0 || amount > balance || isFrozen) {
        return false;  // Precondition not met
    }

    // Perform withdrawal
    balance -= amount;

    // Record transaction (for now, just print it)
    System.out.println("Transaction: Withdraw $" + amount);
    System.out.println("New balance: $" + balance);

    // Postcondition: balance reduced, transaction recorded
    return true;
}
withdraw(100.0);
```

    Transaction: Withdraw $100.0
    New balance: $400.0





    true



## Part 4: Class-Level Documentation

Classes need documentation explaining their overall purpose and usage.

**Key Elements:**
- Overall purpose of the class
- Key responsibilities
- Usage examples
- Important design decisions
- Author and version information

---


```Java
/**
 * Represents a student in the school management system.
 * 
 * This class maintains student information including personal details,
 * academic records, and enrollment status. It provides methods for
 * updating grades, managing course enrollment, and generating reports.
 * 
 * Example usage:
 * <pre>
 * Student alice = new Student("Alice Johnson", 12);
 * alice.enrollInCourse("AP Computer Science");
 * alice.updateGrade("Math", 95.5);
 * System.out.println(alice.getGPA());
 * </pre>
 *
 * @author Your Name
 * @version 1.0
 * @since 2024-01-15
 */
public class Student {
    private String name;
    private int gradeLevel;
    private ArrayList<String> courses;
    private HashMap<String, Double> grades;
    
    // Constructor fix
    public Student(String name, int gradeLevel) {
        this.name = name;
        this.gradeLevel = gradeLevel;
        this.courses = new ArrayList<>();
        this.grades = new HashMap<>();
    }

    // Example methods
    public void enrollInCourse(String course) {
        courses.add(course);
    }

    public void updateGrade(String course, double grade) {
        grades.put(course, grade);
    }

    public double getGPA() {
        if (grades.isEmpty()) return 0.0;
        double sum = 0;
        for (double g : grades.values()) {
            sum += g;
        }
        return sum / grades.size();
    }
}
// Test the Student class
Student alice = new Student("Alice Johnson", 12);
alice.enrollInCourse("AP Computer Science");
alice.updateGrade("Math", 95.5);
System.out.println(alice.getGPA());
```

    95.5


## Part 5: Documentation Best Practices

### DO:
1. **Be specific and actionable** - "sets the student's GPA to the specified value, rounded to one decimal place"
2. **Include examples for complex methods**
3. **Document assumptions and limitations**
4. **Update docs when code changes**
5. **Focus on WHY, not just WHAT**

### DON'T:
1. **Over-document obvious code** - Simple getters/setters don't need documentation
2. **Use vague descriptions** - "processes the data" tells us nothing
3. **Forget edge cases** - What happens with null? Empty arrays?
4. **Let documentation become outdated**

---


```Java
// BAD: Over-documentation of obvious code
/**
 * Gets the name.
 * @return the name
 */
public String getName() {
    return name;
}

// GOOD: No documentation needed for simple accessor
public String getName() { 
    return name; 
}

// GOOD: Document complex behavior
/**
 * Updates the student's name with validation and normalization.
 * 
 * Trims whitespace, converts to proper case, and validates that
 * the name contains only letters, spaces, hyphens, and apostrophes.
 *
 * @param name the new name (will be normalized)
 * @throws IllegalArgumentException if name is null, empty, or contains invalid characters
 */
public void setNameWithValidation(String name) {
    if (name == null || name.trim().isEmpty()) {
        throw new IllegalArgumentException("Name cannot be null or empty");
    }
    this.name = normalizeName(name.trim());
}
```


    |       this.name = normalizeName(name.trim());

    non-static variable this cannot be referenced from a static context

    

    |       this.name = normalizeName(name.trim());

    cannot find symbol

      symbol: variable name

    

    |       this.name = normalizeName(name.trim());

    cannot find symbol

      symbol:   method normalizeName(java.lang.String)

    


## Part 6: AP Exam Connections

### Multiple Choice Tips:
- Know the difference between `//`, `/* */`, and `/** */`
- Understand when documentation is most helpful
- Recognize proper @param and @return usage

### FRQ Requirements:
- **Always document complex methods** - Shows programming maturity
- **Explain your logic** - Helps scorers understand your intent
- **Document non-obvious design decisions**
- **Specify parameter constraints**

### Quick Documentation Checklist:
- ✓ Complex methods have clear purpose descriptions
- ✓ Parameter constraints are specified
- ✓ Return values are explained
- ✓ Edge cases and error conditions are documented
- ✓ Examples provided for non-obvious usage

---

##  Lesson Hack #1: Fix the Documentation

**Task:** The following code has poor documentation. Rewrite it with proper Javadoc comments including preconditions and postconditions.

```java
// Does stuff with numbers
public int doSomething(int[] nums) {
    int result = 0;
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] > 0 && nums[i] % 2 == 0) {
            result += nums[i];
        }
    }
    return result;
}
```

**Your task:** Write proper Javadoc documentation for this method in the code cell below.

---


```Java
/**
 * Calculates the sum of all positive even integers in the given array.
 *
 * <p>This method iterates through the input array and adds up all elements 
 * that are both greater than zero and divisible by two. Negative numbers 
 * and odd numbers are ignored.</p>
 *
 * @param nums an array of integers to be processed
 * @return the sum of all positive even integers in the array;
 *         returns 0 if no such numbers are found or if the array is empty
 *
 * @precondition {@code nums} is not {@code null}
 * @postcondition the returned value equals the sum of all {@code nums[i]} 
 *                where {@code nums[i] > 0} and {@code nums[i] % 2 == 0}
 */
public int doSomething(int[] nums) {
    int result = 0;
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] > 0 && nums[i] % 2 == 0) {
            result += nums[i];
        }
    }
    return result;
}


```

## Popcorn Hack #2: Write Class Documentation

**Your Mission:** Add Javadoc comments to document this GradeBook class!

**What to include:**
- What does this class do? (purpose)
- What are the main features? (key methods)
- How would someone use it? (example)
- Tags: @author, @version, @since
```java
// TODO: Add your class-level Javadoc here!
// Hint: Start with /** and end with */

public class GradeBook {
    private HashMap<String, Double> assignments;
    private HashMap<String, Double> categoryWeights;
    private double extraCredit;
    
    // TODO: Document each method too!
    public void addAssignment(String category, String name, double score) { }
    
    public void setCategoryWeight(String category, double weight) { }
    
    public double calculateFinalGrade() { }
    
    public String generateReport() { }
}


```Java
/**
 * The {@code GradeBook} class manages and calculates student grades based on 
 * assignments, weighted categories, and optional extra credit.
 * <p>
 * This class allows users to:
 * <ul>
 *   <li>Add assignments and their corresponding scores by category.</li>
 *   <li>Set category weights (e.g., Tests = 0.5, Homework = 0.3).</li>
 *   <li>Calculate a final weighted grade based on all entered data.</li>
 *   <li>Generate a formatted report summarizing all grades and weights.</li>
 * </ul>
 * </p>
 * 
 * <p><b>Example usage:</b></p>
 * <pre>{@code
 * GradeBook gb = new GradeBook();
 * gb.setCategoryWeight("Homework", 0.4);
 * gb.setCategoryWeight("Tests", 0.6);
 * gb.addAssignment("Homework", "HW1", 95);
 * gb.addAssignment("Tests", "Midterm", 88);
 * double finalGrade = gb.calculateFinalGrade();
 * System.out.println(gb.generateReport());
 * }</pre>
 *
 * @author Vibha
 * @version 1.0
 * @since 2025-10-10
 */
public class GradeBook {
    private HashMap<String, Double> assignments;
    private HashMap<String, Double> categoryWeights;
    private double extraCredit;

    /**
     * Adds an assignment with the specified category, name, and score.
     *
     * @param category the category of the assignment (e.g., "Homework", "Tests")
     * @param name the name or title of the assignment
     * @param score the numeric score earned for this assignment
     * @precondition {@code category != null && name != null && score >= 0}
     * @postcondition the assignment is added to the {@code assignments} map
     */
    public void addAssignment(String category, String name, double score) { }

    /**
     * Sets the weight for a given grading category.
     *
     * @param category the name of the category
     * @param weight the weight for this category, typically between 0 and 1
     * @precondition {@code category != null && 0 <= weight <= 1}
     * @postcondition {@code categoryWeights} is updated with the new weight
     */
    public void setCategoryWeight(String category, double weight) { }

    /**
     * Calculates the student's final grade using all assignments and category weights.
     *
     * @return the weighted final grade as a {@code double}
     * @precondition categories and assignments have been added
     * @postcondition returns a value between 0 and 100 (or higher with extra credit)
     */
    public double calculateFinalGrade() { return 0.0; }

    /**
     * Generates a formatted report summarizing the student's performance.
     *
     * @return a {@code String} report including assignments, scores, and final grade
     * @precondition assignments and weights are initialized
     * @postcondition returns a human-readable summary of the GradeBook
     */
    public String generateReport() { return ""; }
}

```

Check your answer below!


```Java
/**
 * Manages student grades and calculates final grades based on weighted categories.
 * 
 * This class allows teachers to track assignments across different categories
 * (like homework, tests, projects) and calculate final grades using custom weights.
 * 
 * Key Features:
 * - Store assignments by category
 * - Apply custom weights to each category
 * - Track extra credit points
 * - Generate grade reports
 * 
 * Usage Example:
 * GradeBook myGrades = new GradeBook();
 * myGrades.setCategoryWeight("Homework", 0.30);
 * myGrades.setCategoryWeight("Tests", 0.70);
 * myGrades.addAssignment("Homework", "HW1", 95.0);
 * double finalGrade = myGrades.calculateFinalGrade();
 * 
 * @author Your Name
 * @version 1.0
 * @since 2025-10-06
 */
public class GradeBook {
    private HashMap<String, Double> assignments;
    private HashMap<String, Double> categoryWeights;
    private double extraCredit;
    
    /**
     * Adds an assignment score to a specific category.
     * 
     * @param category the category name (e.g., "Homework", "Tests")
     * @param name the assignment name
     * @param score the score earned (0-100)
     */
    public void addAssignment(String category, String name, double score) { }
    
    /**
     * Sets the weight for a grade category.
     * 
     * @param category the category name
     * @param weight the weight as a decimal (e.g., 0.30 for 30%)
     */
    public void setCategoryWeight(String category, double weight) { }
    
    /**
     * Calculates the final weighted grade including extra credit.
     * 
     * @return the final grade as a percentage
     */
    public double calculateFinalGrade() { }
    
    /**
     * Generates a formatted report of all grades and categories.
     * 
     * @return a String containing the grade report
     */
    public String generateReport() { }
}
```

##  Homework Assignment

### Part 1: Documentation Analysis 
Submission: https://docs.google.com/forms/d/e/1FAIpQLSepOCmW6KeE7jw4f80JO4Kad5YWeDUHKTpnNxnCPTtj9WEAsw/viewform?usp=header 
Rewrite the poorly written code. Write them with proper Javadoc comments.
1. The original code:


```Java
/**
 * The {@code Stuff} class demonstrates a simple example of adding two integers 
 * and printing the result to the console.
 * <p>
 * This class contains a {@code main} method to execute the program 
 * and a helper method {@code add} that performs the addition operation.
 * </p>
 *
 * <p><b>Example output:</b></p>
 * <pre>
 * ans is 15
 * </pre>
 *
 * @author Vibha
 * @version 1.0
 * @since 2025-10-10
 */
public class Stuff {

    /**
     * The entry point of the program. 
     * Initializes two integers, adds them using the {@code add} method, 
     * and prints the result to the console.
     *
     * @param args command-line arguments (not used)
     * @precondition none
     * @postcondition prints the sum of {@code x} and {@code y} to the console
     */
    public static void main(String[] args) {
        int x = 5;
        int y = 10;
        int z = add(x, y);
        System.out.println("ans is " + z);
    }

    /**
     * Adds two integers and returns their sum.
     *
     * @param a the first integer
     * @param b the second integer
     * @return the sum of {@code a} and {@code b}
     * @precondition none
     * @postcondition returns the correct sum of the two integers
     */
    static int add(int a, int b) {
        return a + b;
    }
}

Stuff.main(null);
```

    ans is 15



Submit:

2. Your improved version
3. A brief explanation of what you improved

### Part 2: 
Problem 1: Document a Complex Method
Write complete Javadoc documentation for this method:

public boolean enrollStudent(String studentId, String courseCode, int semester) {
    Student student = findStudentById(studentId);
    if (student == null) return false;

    Course course = findCourseByCode(courseCode);
    if (course == null) return false;

    if (course.isFull()) return false;
    if (student.hasScheduleConflict(course)) return false;
    if (!student.hasPrerequisites(course)) return false;
    if (student.getCreditHours() + course.getCreditHours() > 18) return false;

    student.addCourse(course);
    course.addStudent(student);
    recordEnrollmentTransaction(studentId, courseCode, semester);
    return true;
}


### Part 3: Reflection Questions 
1. Why is documentation more important in team projects than solo projects?
2. Give an example of when a method SHOULD be documented and when it SHOULD NOT.

**Submit:** A Jupyter notebook or Java file with all three parts completed.

---

### Part 2: 



```Java
/**
 * Attempts to enroll a student in a specified course for a given semester.
 * <p>
 * This method checks several enrollment conditions before adding the student 
 * to the course roster:
 * <ul>
 *   <li>Verifies that both the student and course exist.</li>
 *   <li>Ensures the course is not full.</li>
 *   <li>Checks for schedule conflicts.</li>
 *   <li>Confirms all prerequisite courses have been completed.</li>
 *   <li>Prevents the student from exceeding 18 total credit hours.</li>
 * </ul>
 * If all conditions are met, the student is enrolled, the course record is updated, 
 * and an enrollment transaction is recorded.
 * </p>
 *
 * @param studentId the unique identifier for the student attempting to enroll
 * @param courseCode the unique code representing the course to enroll in
 * @param semester the semester number (e.g., 1 for fall, 2 for spring)
 * @return {@code true} if the student was successfully enrolled; 
 *         {@code false} if any condition prevented enrollment
 *
 * @precondition both {@code studentId} and {@code courseCode} must refer to valid records
 * @postcondition if successful, the student and course records are updated to reflect enrollment
 */
public boolean enrollStudent(String studentId, String courseCode, int semester) {
    Student student = findStudentById(studentId);
    if (student == null) return false;

    Course course = findCourseByCode(courseCode);
    if (course == null) return false;

    if (course.isFull()) return false;
    if (student.hasScheduleConflict(course)) return false;
    if (!student.hasPrerequisites(course)) return false;
    if (student.getCreditHours() + course.getCreditHours() > 18) return false;

    student.addCourse(course);
    course.addStudent(student);
    recordEnrollmentTransaction(studentId, courseCode, semester);
    return true;
}


```

### Part 3: 

### 1. Why is documentation more important in team projects than solo projects?

In team projects, **documentation ensures clarity and consistency** across developers. Team members often work on different parts of the same codebase, so clear Javadoc helps others understand the purpose, parameters, and logic of your methods without needing to ask or read through the entire implementation.  
It also helps new team members onboard faster and prevents bugs caused by misunderstandings of how methods are supposed to behave.

In solo projects, you might remember your own logic temporarily — but in a team, **good documentation is the shared memory of the project.**

### 2. Give an example of when a method SHOULD be documented and when it SHOULD NOT.
 **Should be documented:**  
A complex method like `enrollStudent(...)` that performs multiple checks, modifies data, and interacts with several classes. Documentation explains the logic and requirements clearly.

**Should not be documented:**  
A simple private helper method like `incrementCounter()` that adds 1 to a variable. If its purpose is self-explanatory from its name and code, excessive documentation adds clutter without value.


##  Key Takeaways

1. **Documentation is communication** - Write for others (and your future self)
2. **Javadoc format matters** - Use `/** */` with proper tags
3. **Preconditions and postconditions create contracts** - Essential for reliable code
4. **Balance is key** - Don't over-document obvious code, but thoroughly document complex logic
5. **Keep it updated** - Outdated documentation is worse than no documentation
6. **AP Exam success** - Good documentation demonstrates programming maturity on FRQs

### Remember:
> "Code tells you HOW, documentation tells you WHY"

**The collaborative mindset:** Write documentation that you would want to find when using someone else's code. Be specific, be helpful, and anticipate questions.

---

##  Additional Resources
- [Oracle Java Documentation Guidelines](https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html)
- [AP Computer Science A Course Description](https://apcentral.collegeboard.org/)
- Practice writing documentation for existing code projects!

## Challenge Problems (Extra Credit)

### Challenge 1: Document a Recursive Method
Write complete documentation for a recursive method including base case, recursive case, and complexity analysis.

### Challenge 2: Team Documentation Standard
Create a documentation style guide for a team project. Include:
- When to document (and when not to)
- Required tags for different method types
- Example templates
- Common mistakes to avoid

### Challenge 3: Documentation Detective
Find a poorly documented open-source project. Write improved documentation for one class and submit a comparison showing before/after.

---
